---
title: <center> <h1>ECBDB Project - G3</h1> </center>
author: <center>MÃ³nica Fernandes(PG42878), Tiago Machado (PG42884), Tiago Silva (PG42885)</center>
date: <center>`r format(Sys.time(), '%d/%m/%y')`</center>
output:
  html_document:
    theme: spacelab #united, spacelab, journal
    highlight: kate #zenburn, kate, breezedark
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    number_sections: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
.scroll {
  max-height: 300px;
  overflow-y: auto;
}
```

```{=html}
<style>
body {text-align: justify}
div.fontdoc {font-family: georgia;}
    body .main-container {
        max-width: 1750px;
    }
</style>
```
<div class = "fontdoc">

<font size="4">

<a name="topo"></a>

# Packages  

Installation of packages.
```{r packages, eval=FALSE, echo=TRUE}
install.packages("tidyverse")

install.packages("arules")

install.packages("data.table")

install.packages("summarytools")

install.packages("ggpubr")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("limma")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Glimma")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("edgeR")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("org.Hs.eg.db")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("GO.db")

install.packages("car")

install.packages("caret")

install.packages("RColorBrewer")

install.packages("gplots")

install.packages("FactoMineR")

install.packages("factoextra")

```

Import of packages.
```{r, message=FALSE, warning=FALSE, results='hide'}
library(readr)
library(readxl)
library(data.table)
library(tidyverse)
library(readr)
library(arules)
library(dplyr)
library(summarytools)
library(ggpubr)
library(limma)
library(Glimma)
library(edgeR)
library(org.Hs.eg.db)
library(GO.db)
library(car)
library(caret)
library(RColorBrewer)
library(gplots)
library(FactoMineR)
library(factoextra)
library(gprofiler2)  # ADDED: use gprofiler2 for annotation
```

# Datasets

```{r datasets, message=FALSE, warning=FALSE, results='hide'}
# raw counts dataset
raw_counts <- read.csv("CCLE_RNAseq_reads.csv")

# mutations dataset
CCLE_mutations <- read.csv("CCLE_mutations.csv")

# drug response dataset
drug_response <- read.csv("primary-screen-replicate-collapsed-logfold-change.csv")

# sample information dataset
sample_info <- read_excel("sample_info.xlsx")

# drug information dataset
drug_info <- read.csv("primary-screen-replicate-collapsed-treatment-info.csv")

```

## Explanation of the data, origin and relevance.

Within the coursework for the subject "Knowledge Extraction from Biological Databases", we extracted 4 datasets from the DepMap portal (https://depmap.org/portal/). The portal provides multiple datasets aiming to make various cancer cell line data openly available. It includes the Achilles project (gene essentiality across many cell lines) and the CCLE project (Cancer Cell Line Encyclopedia) which profiles genetic and pharmacological characteristics of many cancer models.

We were asked to use an RNA-seq expression dataset for protein-coding genes (raw_counts), which is our primary dataset. Specifically, the dataset corresponds to raw counts from the Achilles project and CCLE characterization data.
We also used a Mutation Annotation Format (MAF)-based dataset representing mutations derived from VCF files produced at project level. This dataset (CCLE_mutations) is our secondary dataset.
As metadata we used the drug_response dataset which measures viability of cell lines exposed to non-oncology compounds (log fold changes). Finally, sample_info contains information about the cell lines referenced in the other datasets.

## Variable preparation

### Dimensions and structure {.tabset}

#### raw_counts {-}

```{r raw_counts, warning=FALSE, class.output="scroll"}
dim(raw_counts)
str(raw_counts, give.attr=FALSE)

```

The raw_counts dataset has 1379 rows (cell lines) and 52440 columns (genes). Cell lines are identified by "DepMapID" and genes by "Hugo Symbol" followed by "ENSEMBL id" in parentheses. All variables are numeric except "X1" which contains the cell line labels.

#### CCLE_mutations {-}

```{r CCLE_mutations, warning=FALSE, class.output="scroll"}
dim(CCLE_mutations)
str(CCLE_mutations, give.attr=FALSE)

```

The CCLE_mutations dataset has 1,288,288 rows (mutations) and 32 descriptive columns. It contains identifiers (e.g., Entrez_Gene_Id, Hugo_Symbol, DepMap_ID) and mutation details (type, position, etc.). The first 11 columns represent part of the MAF format, while the remaining were added by CCLE (e.g., cDNA_Change, isDeleterious, Variant_annotation). DepMap_ID links the mutations to cell lines allowing joins with the other datasets.

#### drug_response {-}

```{r drug_response, warning=FALSE, class.output="scroll"}
dim(drug_response)
str(drug_response, give.attr=FALSE)

```

The drug_response dataset has 578 rows (cell lines) and 4687 columns (drugs). It contains normalized log fold-change cell viability values per drug. Cell lines are identified by "DepMapID" and drugs by "Broad ID". All variables are numeric except the "X" column which contains labels.

#### sample_info {-}

```{r sample_info, warning=FALSE, class.output="scroll"}
dim(sample_info)
str(sample_info, give.attr=FALSE)

```

The sample_info dataset has 1811 rows (cell lines) and 26 descriptive columns, including identifiers (DepMap_ID, COSMICID, CCLE_Name), cell line features (source, culture_type, lineage), and donor info (sex, age). DepMap_ID is key to relate datasets.

### Curation

```{r curadoria, class.output="scroll"}
# process sample_info
# Set as characters
sample_info$COSMICID <- as.character(sample_info$COSMICID)
sample_info$WTSI_Master_Cell_ID <- as.character(sample_info$WTSI_Master_Cell_ID)

# Set as factors
sample_info$sex <- as.factor(sample_info$sex)
sample_info$source <- as.factor(sample_info$source)
sample_info$culture_type <- as.factor(sample_info$culture_type)
sample_info$sample_collection_site <- as.factor(sample_info$sample_collection_site)
sample_info$primary_or_metastasis <- as.factor(sample_info$primary_or_metastasis)
sample_info$primary_disease <- as.factor(sample_info$primary_disease)
sample_info$Subtype <- as.factor(sample_info$Subtype)
sample_info$lineage <- as.factor(sample_info$lineage)
sample_info$lineage_subtype <- as.factor(sample_info$lineage_subtype)
sample_info$lineage_sub_subtype <- as.factor(sample_info$lineage_sub_subtype)
sample_info$lineage_molecular_subtype <- as.factor(sample_info$lineage_molecular_subtype)

# process mutations dataset
# Set as characters
CCLE_mutations$Hugo_Symbol <- as.character(CCLE_mutations$Hugo_Symbol)
CCLE_mutations$Entrez_Gene_Id <- as.character(CCLE_mutations$Entrez_Gene_Id)
CCLE_mutations$NCBI_Build <- as.character(CCLE_mutations$NCBI_Build)

# Set as factors
CCLE_mutations$Strand <- as.factor(CCLE_mutations$Strand)
CCLE_mutations$Variant_Classification <- as.factor(CCLE_mutations$Variant_Classification)
CCLE_mutations$Variant_Type <- as.factor(CCLE_mutations$Variant_Type)
CCLE_mutations$dbSNP_Val_Status <- as.factor(CCLE_mutations$dbSNP_Val_Status)
CCLE_mutations$DepMap_ID <- as.factor(CCLE_mutations$DepMap_ID)
CCLE_mutations$Variant_annotation <- as.factor(CCLE_mutations$Variant_annotation)

```

After identifying variable types we performed manual curation to ensure correct formats for statistical analysis. Several character columns were factorized (e.g., sex), and some numeric-looking identifiers were converted to character (e.g., Hugo_Symbol). Missing values in some non-numeric variables were left as-is or handled later if needed.

# Pre-processing

## Missing values handling

```{r valores_omissos, class.output="scroll"}
# count NA
sum(is.na(raw_counts))
sum(is.na(CCLE_mutations))
sum(is.na(drug_response))
sum(is.na(sample_info))
```

We found NAs in sample_info, drug_response and CCLE_mutation. Only drug_response's NAs (numeric) need immediate treatment because many downstream methods cannot handle NAs. For drug_response we imputed column-wise mean values for NA entries, reasoning that replacing missing responses for a drug with that drug's mean is more appropriate than using a gene-wise mean.

```{r rm_valores_omissos, class.output="scroll"}
# replace NA in drug_response with column mean
for (i in 2:ncol(drug_response)) { 
  m = mean(drug_response[,i], na.rm= TRUE) 
  drug_response[is.na(drug_response[,i]),i] = m 
}

# count NA 
sum(is.na(drug_response)) 
```

## Connections between datasets  

As previously mentioned, datasets are linked by DepMap IDs. We created subsets to keep only cell lines common across datasets for downstream analyses.

```{r subsets, class.output="scroll"}
# Rename columns to DepMap_ID
names(drug_response)[names(drug_response) == "X"] <- "DepMap_ID"
names(raw_counts)[names(raw_counts) == "X"] <- "DepMap_ID"

# Create subsets with cell lines present in drug_response
# Subset raw_counts x CCLE_mutation
sub_raw_counts <- raw_counts %>% filter(raw_counts$DepMap_ID %in% CCLE_mutations$DepMap_ID) 
dim(sub_raw_counts)

# Subset sub_raw_counts x drug_response
sub_raw_counts <- sub_raw_counts %>% filter(sub_raw_counts$DepMap_ID %in% drug_response$DepMap_ID) 
dim(sub_raw_counts)

# Subset sub_raw_counts x sample_info
sub_raw_counts <- sub_raw_counts %>% filter(sub_raw_counts$DepMap_ID %in% sample_info$DepMap_ID) 
dim(sub_raw_counts)

# Subset CCLE_mutations x sub_raw_counts
sub_CCLE_mutations <- CCLE_mutations %>% filter(CCLE_mutations$DepMap_ID %in% sub_raw_counts$DepMap_ID) 

# Subset sample_info x sub_raw_counts
sub_sample_info <- sample_info %>% filter(sample_info$DepMap_ID %in% sub_raw_counts$DepMap_ID) 

# Subset drug_response x sub_raw_counts
sub_drug_response <- drug_response %>% filter(drug_response$DepMap_ID %in% sub_raw_counts$DepMap_ID) 

```

Intersecting datasets yielded 559 cell lines common to all datasets. drug_response was the most limiting dataset.

# Data summarization 

<a name="sum"></a>

## Variable summary {.tabset}

### CCLE_mutations {-}

```{r sumario_mutations, class.output="scroll"}
print(dfSummary(sub_CCLE_mutations, style = 'grid', graph.magnif = 1, valid.col = FALSE,
                max.distinct.values = 5, col.widths = c(100, 200, 200, 350, 500, 250),
                dfSummary.silent  = TRUE, headings = FALSE, justify = 'l')
      , method = 'render', max.tbl.height = 500)

```

After cleaning variable types we computed descriptive statistics for sub_sample_info and sub_CCLE_mutations. We omitted summaries for sub_raw_counts and sub_drug_response due to the high number of numeric variables and computational cost. For sub_CCLE_mutations: chromosome 1 is the most frequent (~10%); Variant_Classification shows Missense_Mutation (~58%) and Silent (~25%); Variant_Type is mostly SNP (~91%). Some annotation columns have many missing values (dbSNP), and some added CCLE columns have many unique values and many missing entries.

<a href="#sum">Back to summary</a>

### sample_info {-}

```{r sumario_sample, class.output="scroll"}
print(dfSummary(sub_sample_info, style = 'grid', graph.magnif = 1, valid.col = FALSE,
                max.distinct.values = 5, col.widths = c(100, 200, 200, 350, 500, 250),
                dfSummary.silent  = TRUE, headings = FALSE, justify = 'l')
      , method = 'render', max.tbl.height = 500)
```

For sub_sample_info: sex distribution ~41% Female, 53% Male, 5% Unknown. Source labs show top providers (ATCC, DSMZ, HSRRB). Mean number of replicates ~2.1. Culture type mainly Adherent (~90%). cas9_activity mean ~74.9 (SD 15.3). primary_or_metastasis distribution Primary 59%, Metastasis 41%. Age mean 53. Many missing entries in some variables.

<a href="#sum">Back to summary</a>

## Plots supporting summary

```{r graph_sum, class.output="scroll", fig.align='center'}
# Pie Chart Variant type
w = table(sub_CCLE_mutations$Variant_Type)
t = as.data.frame(w)

slices <- t$Freq
lbls <- t$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels
lbls <- paste(lbls,"%",sep="") # add % to labels
pie(slices,labels = lbls, col = c("darkslategray1", "coral", "darkolivegreen1", "navajowhite"),
   main="Variant Type")

w2 = table(sub_CCLE_mutations$Variant_annotation)
t2 = as.data.frame(w2)

# Pie Chart Variant annotation
slices <- t2$Freq
lbls <- t2$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels
lbls <- paste(lbls,"%",sep="") # add % to labels
pie(slices,labels = lbls, col = c("darkslategray1", "coral", "darkolivegreen1", "navajowhite"),
   main="Variant Annotations")

# Test homogeneity of variances
leveneTest(sub_sample_info$age ~ sub_sample_info$sex)
# There is no evidence to suggest the variance across groups is statistically significantly different

# Compute ANOVA
res.aov <- aov(sub_sample_info$age ~ sub_sample_info$sex)

# Summary of ANOVA
summary(res.aov)
# No differences

# Boxplot Age vs Sex
boxplot(age ~ sex, data = sub_sample_info, main = "Age vs Sex", xlab = "Sex", ylab = "Age (years)", col = c("darkslategray1", "coral", "darkolivegreen1"))

# Histogram Cas9_Activity
hist(sub_sample_info$cas9_activity, main = "Cas9 Activity", xlab = "Percentage", ylab = "Number of cell lines", col = "navajowhite")

```
We created pie charts for Variant_Type and Variant_annotation, performed ANOVA on age vs sex (no significant difference), and plotted boxplot and histogram for supporting visuals.

# Differential expression

## Metadata preparation  

To run differential expression we selected metadata: primary_or_metastasis (type) and a derived variable mut_counts (count of mutations per cell line) from CCLE_mutations.

```{r prep_meta, class.output="scroll"}
# 1st metadata --> count mutations per cell line
# group by cell lines
mutation_counts  <- CCLE_mutations %>% 
  group_by(DepMap_ID) %>%
  summarise(mut_freq = length(DepMap_ID))

# Descriptive analysis of mut_freq
descr(mutation_counts$mut_freq)

# Discretize into 3 levels (Low, Medium, High) by frequency
mutation_counts$mut_counts <- discretize(mutation_counts$mut_freq, method = "frequency", breaks = 3, labels = c("Low", "Medium", "High")) 

# set row names to DepMap_ID
mutation_counts <- mutation_counts %>% remove_rownames %>% column_to_rownames(var="DepMap_ID")

# inspect structure and distribution
str(mutation_counts)
freq(mutation_counts$mut_counts)


# 2nd metadata - Primary or Metastasis
# Create dataframe with cell lines and cancer type (primary or metastasis)
prim_met = data.frame(label = sample_info$DepMap_ID, type = sample_info$primary_or_metastasis)

# Set "type" as factor
prim_met$type <- as.factor(prim_met$type) 

# Distribution by cancer type
freq(prim_met$type)

# set row names
prim_met <- prim_met %>% remove_rownames %>% column_to_rownames(var="label")

# Merge mutation counts and cancer type by cell line
metadados <- merge(mutation_counts, prim_met, by=0, all=TRUE)

# Omit rows with NA
metadados_2 <- metadados
metadados_2$type <- NULL
clean_metadados <- na.omit(metadados)
dfSummary(clean_metadados)

# Datasets for differential expression
meta_expression <- raw_counts %>% filter(raw_counts$DepMap_ID %in% clean_metadados$Row.names)

meta_intersect <- clean_metadados %>% filter(clean_metadados$Row.names %in% meta_expression$DepMap_ID)

# Verify intersection
dim(meta_expression)
dim(meta_intersect)

```

We counted mutations per DepMap_ID to produce mut_freq and discretized into mut_counts with three roughly equally-sized bins: Low, Medium, High. type is taken from primary_or_metastasis and entries with NA were omitted. The resulting clean_metadados and meta_expression were intersected to produce matched expression and metadata for differential analysis.

## Univariate analysis on metadata

We explored the metadata with descriptive stats and non-parametric tests where appropriate.

```{r univar, class.output="scroll", fig.align='center'}
# Descriptive stats
descr(mutation_counts$mut_freq)

# Density plot
ggdensity(clean_metadados$mut_freq, 
          main = "Mutation Counts",
          xlab = "Number of Mutations")

# Q-Q plot
ggqqplot(clean_metadados$mut_freq, 
         main = "Mutation Counts")
# Clearly not normal

# Shapiro-Wilk - Normality
shapiro.test(clean_metadados$mut_freq)
# Not normal

# Homogeneity of variances
leveneTest(clean_metadados$mut_freq ~ clean_metadados$type)
# There is no evidence to suggest variance across groups is significantly different

leveneTest(clean_metadados$mut_freq ~ clean_metadados$mut_counts)
# There is evidence to suggest variance across groups is significantly different

## Tests on means
# Wilcoxon test for two groups - freq vs type
wilcox.test(clean_metadados$mut_freq ~ clean_metadados$type,
                   exact = FALSE)

# Box plot - types
p<-ggboxplot(clean_metadados, x = "type", y = "mut_freq", 
          color = "type", palette = c("#00AFBB", "#E7B800"),
          ylab = "Weight", xlab = "Groups")

ggpar(p, ylim = c(0,1000), main = "Cancer Type")

# Kruskal-Wallis - freq vs counts
res.krusk <- kruskal.test(clean_metadados$mut_freq ~ clean_metadados$mut_counts)
res.krusk

pairwise.wilcox.test(clean_metadados$mut_freq, clean_metadados$mut_counts,
                     p.adjust.method = "BH")

# Box plot - counts
p2<-ggboxplot(clean_metadados, x = "mut_counts", y = "mut_freq", 
          color = "mut_counts", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
          ylab = "Weight", xlab = "Treatment")

ggpar(p2, ylim = c(0,2000), main = "Mutation Counts")

```

mut_freq is not normally distributed (Shapiro), so non-parametric tests were used: Wilcox for two-group comparisons and Kruskal-Wallis for three-group comparisons (followed by pairwise Wilcox with BH correction). Significant differences were observed across mut_counts groups.

## Generate expression matrix

meta_expression had DepMap_ID set as rownames, ordered and transposed to build exp_matrix for differential expression.

```{r exp_matrix, class.output="scroll"}
# Set rownames and transpose expression data
meta_expression <- meta_expression %>% remove_rownames %>% column_to_rownames(var="DepMap_ID")

# Order cell line ids
meta_expression_ordered <- meta_expression[ order(row.names(meta_expression)), ]

# Transpose expression matrix
exp_matrix <- t(meta_expression_ordered)

```

## Create gene annotations

We extracted ENSEMBL IDs from rownames of exp_matrix and used org.Hs.eg.db to map ENTREZID, SYMBOL and GENENAME. Genes without annotation were removed.

```{r AnotaÃ§Ãµes, class.output="scroll"}
# Extract Ensembl ids from rownames
ensembl_ids <- stringr::str_extract(row.names(exp_matrix), "ENSG[0-9]+")
row.names(exp_matrix) <- ensembl_ids

# Use gprofiler2 to map Ensembl IDs to annotation
gmap <- gconvert(query = unique(ensembl_ids), organism = "hsapiens")

# Get valid ENSEMBL IDs from gprofiler2 mapping
valid_ensembl <- gmap$target

# Subset exp_matrix to keep only rows with valid ENSEMBL IDs
exp_matrix <- exp_matrix[rownames(exp_matrix) %in% valid_ensembl, ]

```

## Differential expression analysis

We used the limma pipeline for differential expression analysis. First, we filtered out lowly expressed genes.

```{r filtro_expressao, class.output="scroll"}
# Load into edgeR
y <- DGEList(counts = exp_matrix)

```

### Metadata preparation

We used the same metadata as in the previous analysis.

### Differential expression

```{r exp_diferencial, class.output="scroll"}

#Design for mutation types
Cancer_type <- meta_intersect$type


# Design for primary vs metastasis
design = model.matrix(~0+Cancer_type, data = y$samples)
colnames(design) <- levels(Cancer_type)

# Make contrasts
contrast <- makeContrasts(Metastasis - Primary, levels=design)


keep <- filterByExpr(y, design)
y <- y[keep, , keep.lib.sizes=FALSE]

# Normalization for composition bias
y <- calcNormFactors(y)


# Limma voom pipeline
v <- voom(y, design, plot = FALSE)

fit <- lmFit(v, design)
fit.cont <- contrasts.fit(fit, contrast)
fit.cont <- eBayes(fit.cont)

# Results
results <- topTable(fit.cont, coef="Metastasis - Primary")
```

Results showed 17,049 genes passed the filter. We found 1,488 underexpressed and 1,815 overexpressed genes in metastasis compared to primary samples.

### GO enrichment analysis

We performed GO enrichment analysis on the differentially expressed genes.

```{r go_enriquecimento, class.output="scroll"}
# GO enrichment using gprofiler2::gost instead of goana
# Select DE genes for enrichment (example: topTable results, or other selection)
de_genes <- rownames(results)[results$adj.P.Val < 0.05] # or other threshold/logic

# Run gprofiler2 enrichment using ENSEMBL IDs
go_res <- gost(query = de_genes, organism = "hsapiens", sources = c("GO:BP", "GO:MF", "GO:CC"))

# Show top results
head(go_res$result, 10)
```

GO analysis showed mainly underexpression of immune response and stimulus response terms for metastasis vs primary.

<a href="#meta">Back to analysis</a>

### Mutation_count {-}

```{r mutation_count, class.output="scroll", fig.align='center'}
# Load into edgeR
y <- DGEList(counts = exp_matrix)

# Design for mutation count
Mutation_count <- meta_intersect$mut_counts 

design = model.matrix(~0+Mutation_count, data = y$samples)
colnames(design) <- levels(Mutation_count)
design

# Make contrasts
contrast <- makeContrasts(MvsL=Medium-Low, 
                          HvsM=High-Medium,
                          HvsL=High-Low
                          ,levels=design)

keep <- filterByExpr(y, design)
y <- y[keep, , keep.lib.sizes=FALSE]

barplot(y$samples$lib.size,names=colnames(y),las=2)
# Add a title to the plot
title("Barplot of library sizes")

# Normalization for composition bias
y <- calcNormFactors(y)


# Start limma voom pipeline
par(mfrow=c(1,1))

v <- voom(y,design,plot = TRUE)

# Limma - Trend
fit <- lmFit(v, design)

fit.cont <- contrasts.fit(fit, contrast)

fit.cont <- eBayes(fit.cont, trend = F, robust = F)

summa.fit <- decideTests(fit.cont)

summary(summa.fit)

vennDiagram(summa.fit)

topTable(fit.cont, coef="HvsL")

# Genome-wide plots
plotMD(fit.cont,coef="HvsL",status=summa.fit[,"HvsL"], values = c(-1, 1), hl.col=c("blue","red"), main = "HvsL")

volcanoplot(fit.cont,coef="HvsL",highlight=100,names=y$genes$SYMBOL, main="HvsL")

glXYPlot(x=fit.cont$coefficients[,1], y=fit.cont$lods[,1],
         xlab="logFC", ylab="B", main="HvsL",
         counts=v$E, groups=Mutation_count, status=summa.fit[,1],
         anno=fit.cont$genes, side.main="ENSEMBL", folder="mut_counts_volcano", html = 'mut_counts_volcano')


# Testing relative to a threshold - TREAT
fit.treat <- treat(fit.cont,lfc=log2(1.2))

res.treat <- decideTests(fit.treat)

summary(res.treat)

result_treat <- topTreat(fit.treat, coef="HvsL", number = Inf)

# Treat plots
plotMD(fit.treat,coef="HvsL",status=res.treat[,"HvsL"], values = c(-1, 1), hl.col=c("blue","red"), main = "HvsL (TREAT)")

volcanoplot(fit.treat,coef="HvsL",highlight=100,names=y$genes$SYMBOL, main="HvsL (TREAT)")

glMDPlot(fit.treat, coef="HvsL", counts=v$E, groups=Mutation_count,
         status=res.treat, side.main="ENSEMBL", main="HvsL",
         folder="mut_counts_md", html = 'mut_counts_md')



# Extract ENSEMBL IDs from DE gene rownames
de_genes_raw <- rownames(result_treat)[result_treat$adj.P.Val < 0.05]
de_genes <- stringr::str_extract(de_genes_raw, "ENSG[0-9]+")
de_genes <- na.omit(de_genes)

# Run gprofiler2 enrichment using ENSEMBL IDs
go_res <- gost(query = de_genes, organism = "hsapiens", sources = c("GO:BP", "GO:MF", "GO:CC"))

# Show top results
head(go_res$result, 10)

```

Contrasts MvsL, HvsM, HvsL were defined. After filtering 18,306 genes remained. TREAT results: MvsL -> 2 overexpressed; HvsM -> 18 under, 12 over; HvsL -> 698 under, 587 over. GO results for HvsL suggest underexpression of ECM, angiogenesis and cell adhesion related genes in high vs low mutation loads.

<a href="#meta">Back to analysis</a>

### Combination {-}

```{r combined, class.output="scroll", fig.align='center'}
# Load into edgeR
y <- DGEList(counts = exp_matrix)

# Design for combined groups
Cancer_type <- meta_intersect$type
Mutation_count <- meta_intersect$mut_counts
Group <- factor(paste(Cancer_type,Mutation_count,sep="."))

design = model.matrix(~0+Group, data = y$samples)
colnames(design) <- levels(Group)
design

# Make contrasts
contrast <- makeContrasts(MHvsPH = Metastasis.High-Primary.High, 
                          MLvsPL = Metastasis.Low-Primary.Low,
                          MHvsML = Metastasis.High-Metastasis.Low,
                          PHvsPL = Primary.High-Primary.Low,
                          MHvsPL = Metastasis.High-Primary.Low,
                          PHvsML = Primary.High-Metastasis.Low,
                          levels=design)

keep <- filterByExpr(y, design)
y <- y[keep, , keep.lib.sizes=FALSE]

barplot(y$samples$lib.size,names=colnames(y),las=2)
# Add a title to the plot
title("Barplot of library sizes")

# Calculate normalization factors (TMM)
y <- calcNormFactors(y)


# Start limma voom pipeline
par(mfrow=c(1,1))

v <- voom(y,design,plot = TRUE)

# Limma - Trend
fit <- lmFit(v, design)

fit.cont <- contrasts.fit(fit, contrast)

fit.cont <- eBayes(fit.cont, trend = F, robust = F)

summa.fit <- decideTests(fit.cont)

summary(summa.fit)

topTable(fit.cont, coef="MHvsPL")


# Genome-wide plots
plotMD(fit.cont,coef="MHvsPL",status=summa.fit[,"MHvsPL"], values = c(-1, 1), hl.col=c("blue","red"), main = "MHvsPL")

volcanoplot(fit.cont,coef="MHvsPL",highlight=100,names=y$genes$SYMBOL, main ="MHvsPL")

glXYPlot(x=fit.cont$coefficients[,'MHvsPL'], y=fit.cont$lods[,'MHvsPL'],
         xlab="logFC", ylab="B", main="MHvsPL",
         counts=v$E, groups=Group, status=summa.fit[,'MHvsPL'],
         anno=fit.cont$genes, side.main="ENSEMBL", folder="combined_volcano", html = "combined_volcano")


# Testing relative to a threshold - TREAT
fit.treat <- treat(fit.cont,lfc=log2(1.2))

res.treat <- decideTests(fit.treat)

summary(res.treat)

# MHvsPL
topTreat(fit.treat, coef="MHvsPL")

# PHvsPL
topTreat(fit.treat, coef="PHvsPL")

# MHvsPL plot
plotMD(fit.treat,coef="MHvsPL",status=res.treat[,"MHvsPL"], values = c(-1, 1), hl.col=c("blue","red"), main = "MHvsPL (TREAT)")

volcanoplot(fit.treat,coef="MHvsPL",highlight=100,names=y$genes$SYMBOL, main = "MHvsPL (TREAT)")

glMDPlot(fit.treat, coef="MHvsPL", counts=v$E, groups=Group,
         status=res.treat, side.main="ENSEMBL", main="MHvsPL",
         folder="combined_md", html = "combined_md")

# PHvsPL
plotMD(fit.treat,coef="PHvsPL",status=res.treat[,"PHvsPL"], values = c(-1, 1), hl.col=c("blue","red"), main = "PHvsPL (TREAT)")

volcanoplot(fit.treat,coef="PHvsPL",highlight=100,names=y$genes$SYMBOL, main = "PHvsPL (TREAT)")


# GO enrichment using goana on Treat results

# GO enrichment using gprofiler2::gost for MHvsPL
de_genes_MHvsPL_raw <- rownames(topTreat(fit.treat, coef="MHvsPL", number=Inf))[topTreat(fit.treat, coef="MHvsPL", number=Inf)$adj.P.Val < 0.05]
de_genes_MHvsPL <- stringr::str_extract(de_genes_MHvsPL_raw, "ENSG[0-9]+")
de_genes_MHvsPL <- na.omit(de_genes_MHvsPL)
go_MHvsPL <- gost(query = de_genes_MHvsPL, organism = "hsapiens", sources = c("GO:BP", "GO:MF", "GO:CC"))
head(go_MHvsPL$result, 10)

# GO enrichment using gprofiler2::gost for PHvsPL
de_genes_PHvsPL_raw <- rownames(topTreat(fit.treat, coef="PHvsPL", number=Inf))[topTreat(fit.treat, coef="PHvsPL", number=Inf)$adj.P.Val < 0.05]
de_genes_PHvsPL <- stringr::str_extract(de_genes_PHvsPL_raw, "ENSG[0-9]+")
de_genes_PHvsPL <- na.omit(de_genes_PHvsPL)
go_PHvsPL <- gost(query = de_genes_PHvsPL, organism = "hsapiens", sources = c("GO:BP", "GO:MF", "GO:CC"))
head(go_PHvsPL$result, 10)

```

Multiple contrasts across combined groups were evaluated. After filtering 20,307 genes remained. MHvsPL had many differential genes; TREAT reduced counts but still left substantial numbers. GO analyses reflect underexpression of immune response terms for MHvsPL and changes related to ECM and cell migration for PHvsPL.

<a href="#meta">Back to analysis</a>

# Multivariate analysis

## Pre-processing

```{r analise multivariada, class.output="scroll"}
## New exp matrix for MH and PL lineages
comb_exp = as.data.frame(cbind(Group, t(exp_matrix)))
select = c("4", "5")
comb_exp$Group = as.factor(comb_exp$Group)
comb_exp = comb_exp[comb_exp$Group %in% select, ]
comb_exp$Group = as.factor(comb_exp$Group)
comb_exp$Group <- factor(comb_exp$Group, labels = c("Primary.High", "Primary.Low"))
groups_combine <- comb_exp$Group


# Get differentially expressed genes for contrast PHvsPL
genes_diff = topTreat(fit.treat, coef="PHvsPL", number=100)

# Filter the expression matrix to consider these genes
indexes = which(names(comb_exp)%in%rownames(genes_diff))
exp_mut = comb_exp[,indexes]

logcounts_genes <- cpm(t(exp_mut), log=TRUE)

```

We selected 100 top genes from PHvsPL and built a matrix for 403 primary cell lines labeled Primary.High or Primary.Low, generating log CPM values.

## Unsupervised analysis

### Heatmap and hierarchical clustering

```{r heatmap yo, class.output="scroll", fig.align='center'}
# choose colors
mypalette <- brewer.pal(11,"RdYlBu")
morecols <- colorRampPalette(mypalette)
col.cell <- c("darkslategray1", "coral")[groups_combine]

heatmap.2(logcounts_genes,col=rev(morecols(50)), trace="none", main="100 differentially expressed genes PHvsPL", ColSideColors = col.cell, scale="row")
legend(-0.1, -0.125, legend=levels(groups_combine), fill=c("darkslategray1", "coral"), xpd = T)

```

The heatmap shows clusters with distinct expression patterns enriched for Primary.High vs Primary.Low in some clusters.

### Principal Component Analysis (PCA)

```{r pca, class.output="scroll", fig.align='center'}
res.pca<-PCA(t(logcounts_genes), scale.unit = F, graph = F)

eig.val <- get_eigenvalue(res.pca)
eig.val[1:10,]

# Number of dimensions until we reach 90% cumulative variance
i = 1
while ( eig.val[i,3] < 90 ) i = i + 1
i

fviz_famd_ind(res.pca, geom = c("point"), col.ind = "cos2", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
              palette = "rainbow", addEllipses = FALSE, ellipse.type = "confidence",
              ggtheme = theme_minimal(), repel = TRUE, labels = F)  

fviz_famd_ind(res.pca, geom = c("point"),
              habillage = groups_combine, # color by groups 
              palette = c("rainbow"),
              addEllipses = FALSE, ellipse.type = "confidence", 
              repel = TRUE, invisible = "quali.var", labels = FALSE )

```

PCA shows first three components explain ~40% variance; some trend of Primary.High grouping on negative PC1, but not a clear separation.

### k-means clustering

```{r kmeans, class.output="scroll", fig.align='center'}
# Kmeans comparison with PCA
fviz_nbclust(t(logcounts_genes), kmeans, method = "silhouette")

kmm_genes <- kmeans(t(logcounts_genes), 2)

col.cell <- c( "coral","darkslategray1")[groups_combine]
col.cell_Kmm <- c("darkslategray1", "coral")[kmm_genes$cluster]

plot(res.pca$ind$coord[, 1], res.pca$ind$coord[, 2], col = col.cell_Kmm, pch = 16, xlab = "PC1", ylab = "PC2", main ="Map of predicted clusters")
legend(27, -25, legend=c("1", "2"),fill=c("darkslategray1", "coral"), xpd = T)

plot(res.pca$ind$coord[, 1], res.pca$ind$coord[, 2], col = col.cell, pch = 16, xlab = "PC1", ylab = "PC2", main ="Map of observed data")
legend(17, -25, legend=levels(groups_combine),fill=c( "coral","darkslategray1"), xpd = T)

```

De forma a efetuar um *k-means clustering* sobre o *dataset* afim de encontrar os *clusters* teÃ³ricos, foi construÃ­do um *silhouette plot* para verificar o nÃºmero Ã³timo de *clusters* a utilizar, tendo-se optado por $2$ *clusters.*  
De seguida, foi efetuado o *clustering* em si tendo resultado em 2 grupos que se separam uniformemente ao longo do primeiro componente.  
A comparaÃ§Ã£o destes *clusters* com aqueles obtidos pela sobreposiÃ§Ã£o da informaÃ§Ã£o dos grupos reforÃ§a a conclusÃ£o anterior da mÃ¡ separaÃ§Ã£o das linhagens por esta caracterÃ­stica ao longo do mapa fatorial.

<a name="ML2"></a>

### AnÃ¡lise supervisionada (Machine Learning) {.tabset}

Mediante os resultados antes obtidos, propusemo-nos a construir um modelo de *machine learning* para efetuar a previsÃ£o da aÃ§Ã£o da simvastatina sobre as linhagens celulares estando isto representado na classificaÃ§Ã£o das linhagens como tendo uma baixa aÃ§Ã£o (*"Low"*) ou uma alta aÃ§Ã£o (*"High"*) da simvastatina. Foram usados $100$ genes preditores provenientes da expressÃ£o diferencial, juntamente com $559$ linhagens cancerÃ­genas.  

Para tal foram testadas 5 *frameworks*: **"Neural Networks"**, **"Random Forest"**, **"Decision Trees"**, **"K Nearest Neighbors"** e **"NaÃ¯ve Bayes"**.  

Em todos os modelos foi utilizada uma estimaÃ§Ã£o do erro corresponde a **validaÃ§Ã£o cruzada** com 10 *folds* repetida 5 vezes, aquando da sua construÃ§Ã£o. De forma a tornar estes resultados replicÃ¡veis, foi invocada uma *seed* de valor "16718".  

```{r drug_ml, class.output="scroll"}
#seed para ser sempre igual
set.seed(16718)
#repeated cross validation
cv.control = trainControl('repeatedcv', number = 10, repeats = 5)

#dataframe ML
ml_phpl <- as.data.frame(cbind(group = groups_combine, t(logcounts_genes)))

ml_phpl$group = as.factor(ml_phpl$group)

```


#### Neural Networks {-}

```{r drug_nnet, echo=TRUE, results='hide', class.output="scroll"}
#Neural Networks -- Classification, Regression
set.seed(16718)
phpl_nnet_cv = train(group~., data = ml_phpl, method = "nnet", tuneLenght=10, trControl=cv.control)

```

```{r drug_nnet_4, class.output="scroll"}
phpl_nnet_cv

```

Na construÃ§Ã£o do modelo por **"Neural Networks"** foi dado o argumento *"tuneLenght = 10"*, correspondendo isto ao nÃºmero combinaÃ§Ãµes aleatÃ³rias de hiperparÃ¢metros possÃ­veis a utilizar pelo algoritmo na sua construÃ§Ã£o.  
Obtivemos que os parÃ¢metros selecionados correspondem a um *"size"* 1 (nÃºmero de unidades na camada intermÃ©dia) e a um *"decay"* (regularizaÃ§Ã£o para evitar sobreajustamento) de 0.1, possuindo o modelo uma **precisÃ£o** de aproximadamente $0.62$.   

<a href="#ML2">Voltar Ã  anÃ¡lise</a>

#### Random Forests {-}

```{r drug_rf_1, class.output="scroll"}
#Random Forest -- Classification, Regression
set.seed(16718)
phpl_rf_cv = train(group~., data = ml_phpl, method = "rf", tuneLenght=10, trControl=cv.control)

phpl_rf_cv

```

Na construÃ§Ã£o do modelo por **"Random Forest"** foi dado o argumento *"tuneLenght = 10"*, correspondendo isto ao nÃºmero combinaÃ§Ãµes aleatÃ³rias de hiperparÃ¢metros possÃ­veis a utilizar pelo algoritmo na sua construÃ§Ã£o.  
Obtivemos que os parÃ¢metros selecionados correspondem a um *"mtry"* de 2 (nÃºmero de variÃ¡veis randomizadamente amostradas como candidatas a cada ramificaÃ§Ã£o), possuindo o modelo uma **precisÃ£o** de aproximadamente $0.63$.  


<a href="#ML2">Voltar Ã  anÃ¡lise</a>

#### Decision Trees {-}

```{r drug_rpart_1, class.output="scroll"}
#Decision Trees -- Classification, Regression
set.seed(16718)
phpl_tree_cv = train(group~., data = ml_phpl, method = "rpart", tuneGrid=expand.grid(.cp=0.2), trControl=cv.control)

phpl_tree_cv
```

Na construÃ§Ã£o do modelo por **"Decision Trees"** foi dado o argumento *"expand.grid = (.cp=0.2)"*, correspondendo isto ao nÃºmero combinaÃ§Ãµes aleatÃ³rias de hiperparÃ¢metros possÃ­veis a utilizar pelo algoritmo na sua construÃ§Ã£o.  
Obtivemos que os parÃ¢metros selecionados correspondem a um *"cp"* a um valor constante de 0.2 (complexidade do parÃ¢metro e dos valores de erro associados), possuindo o modelo uma **precisÃ£o** de aproximadamente $0.58$.  

<a href="#ML2">Voltar Ã  anÃ¡lise</a>

#### k Nearest Neighbors {-}

```{r drug_knn_1, class.output="scroll"}
#KNN -- Classification, Regression
set.seed(16718)
phpl_knn_cv = train(group~., data = ml_phpl, method = "knn", tuneGrid = expand.grid(k = 1:10), trControl=cv.control)

phpl_knn_cv

```

Na construÃ§Ã£o do modelo por **"k Nearest Neighbours"** foi dado o argumento *"tuneLenght = expand.grid = (1:10)"*, ou seja o nÃºmero de vizinhos a ser implementados pelo algoritmo.  
Obtivemos que os parÃ¢metros selecionados correspondem a um *"k"* de 10 (nÃºmero de vizinhos), possuindo o modelo uma *precisÃ£o* de aproximadamente $0.62$.  

<a href="#ML2">Voltar Ã  anÃ¡lise</a>

#### NaÃ¯ve Bayes {-}

```{r drug_nb, warning=FALSE, class.output="scroll"}
#Naive Bayes -- Classification
set.seed(16718)
phpl_nb_cv = train(group~., data = ml_phpl, method = "nb", trControl=cv.control)

phpl_nb_cv

```

Na construÃ§Ã£o do modelo por **"NaÃ¯ve Bayes"** foi dado o argumento *"tuneLenght = 10"*, correspondendo isto ao nÃºmero combinaÃ§Ãµes aleatÃ³rias de hiperparÃ¢metros possÃ­veis a utilizar pelo algoritmo na sua construÃ§Ã£o.  
Obtivemos que os parÃ¢metros selecionados correspondem a um *"fL"* de 0 (incorporaÃ§Ã£o da suavizaÃ§Ã£o de Laplace), a ausÃªncia do uso de um *"kernel"* (uso de uma *kernel density estimate*) e um *"adjust = 1"* (ajuste da largura de banda da da *kernel density*), possuindo o modelo uma **precisÃ£o** de aproximadamente $0.63$.  

<a href="#ML2">Voltar Ã  anÃ¡lise</a>

### Resultados *machine learning*

ApÃ³s observaÃ§Ã£o da precisÃ£o dos 5 modelos para a classificaÃ§Ã£o das linhagens cancerÃ­genas, selecionou-se o modelo obtido a partir do algoritmo de **"Random Forest"** como aquele com maior **precisÃ£o** entre os restantes, tomando esta o valor de $63\%$.  
Este valor Ã© subÃ³timo para a performance de um algoritmo de *machine learning*, contudo, pode ser melhorado com a adiÃ§Ã£o de mais entradas de dados, ou com enriquecimento de genes ou de outras variÃ¡veis que permitam melhor classificar estas classes.  

### ImportÃ¢ncia das variÃ¡veis

```{r drug_imp, class.output="scroll"}
control <- rfeControl(functions=rfFuncs, method="cv", number=10)
results <- rfe(group~., data = ml_phpl, rfeControl=control, sizes=c(1:10,20,40,60,80,100))
results
```

```{r drug_imp_2, class.output="scroll"}
control <- rfeControl(functions=rfFuncs, method="cv", number=10)
results <- rfe(group~., data = ml_phpl, rfeControl=control, sizes=c(1:10,20,40,60,80,100))
results
important_genes <- predictors(results)
important_genes

```

Por Ãºltimo, foi realizada a seleÃ§Ã£o de atributos para o *dataset* considerado para *machine learning*, atravÃ©s do mÃ©todo de *Recursive Feature Elimination*. Este algoritmo foi implementado com uma estimaÃ§Ã£o do erro correspondente a validaÃ§Ã£o cruzada 10 *folds*.  
AtravÃ©s do argumento *"sizes"*, foi dado ao algoritmo o tamanho das amostragens de variÃ¡veis a testar. Foi entÃ£o determinado que dos $100$ genes fornecidos, $4$ permitiam uma melhor precisÃ£o do algoritmo.  
A anÃ¡lise das designaÃ§Ãµes destes genes revelam-nos, consistentemente, um conjunto de genes predominantemente ligados a funÃ§Ãµes relacionadas com a membrana celular e com tecidos epiteliais, o que Ã© consistente com as anÃ¡lises anteriores.  

<a href="#topo">Voltar ao inÃ­cio</a>
